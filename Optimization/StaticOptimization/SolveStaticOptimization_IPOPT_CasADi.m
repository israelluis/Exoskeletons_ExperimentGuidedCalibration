function DatStore = SolveStaticOptimization_IPOPT_CasADi(DatStore,Misc,trial,Exo_Mode)
% SolveStaticOptimization_IPOPT_CasADi solves the muscle redundancy problem
% assuming rigid tendons.

%% Inputs
% the number of muscles, dofs, frames
time = DatStore(trial).time;
N = length(time);
M = DatStore(trial).nMuscles;
nDOF = DatStore(trial).nDOF;

% get current position on F/L and F/V curves (assuming rigid tendons)
act = ones(N,M);
FMltilde = ones(N,M);
FMvtilde = ones(N,M);
Fpe = ones(N,M);
cos_alpha = ones(N,M);
for m = 1:M
    pp_y = spline(time,DatStore(trial).LMT(:,m));
    [LMTg,vMTg,~] = SplineEval_ppuval(pp_y,time,1);
    [~, ~, FMltilde(:,m), FMvtilde(:,m), Fpe(:,m), cos_alpha(:,m)] = ...
        HillModel_RigidTendon(act(:,m),LMTg,vMTg,Misc.params(:,m));
    clear pp_y 
end
FMo = ones(size(act,1),1)*Misc.FMo;
Fpas = FMo.*Fpe.*cos_alpha;
Fact = FMo.*FMltilde.*FMvtilde.*cos_alpha;

% Optimal force reserve actuators
Topt = 1;

%get the ID data
ID_data = DatStore(trial).T_exp;
%% Formulate and solve optimization problem
% ----------------------------
import casadi.*
opti    = casadi.Opti();   % Create opti instance

% optimization variables
a       = opti.variable(N,M); % muscle activations
ar      = opti.variable(N,nDOF); % reserve actuators

% initial guess
opti.set_initial(a,0);
opti.set_initial(ar,0);

% bounds on optimization variables
opti.subject_to(0 < a < 1);
opti.subject_to(-1500000 <ar < 1500000);

% constraints: equilibrium of forces
Fm = a.*Fact + Fpas;

if Misc.Exo_Enable && Exo_Mode
NExo=length(Misc.Exo_Dof);

% get kinematics and time
iSel = find(ismember(Misc.DofNames_Input,Misc.Exo_Dof));
qSel = DatStore(trial).q_exp(1:N,iSel);
time_mesh=time;
t_toe_off=Misc.toe_off_timing;
        
if strcmp(Misc.Exo_Type,'active') && strcmp(Misc.Exo_Mode,'optimal')
    
elseif strcmp(Misc.Exo_Type,'quasi') && strcmp(Misc.Exo_Mode,'optimal')
    % initialization
    Exo_kvalue= opti.variable(trial,NExo);  %stiffness
    timeExo_i = opti.variable(trial,NExo);  %engage clutching time
    timeExo_f = opti.variable(trial,NExo);  %disengage clutching time   

    Exo_kvalue_lim=NaN(NExo,2);
    timeExo_i_lim =NaN(NExo,2);
    timeExo_f_lim =NaN(NExo,2);

    Exo_kvalue_IG =NaN(NExo,1);
    timeExo_i_IG  =NaN(NExo,1);
    timeExo_f_IG  =NaN(NExo,1);      
            
    for ExoSel=1:length(Misc.Exo_Dof)
        Exo_Dof_sel=Misc.Exo_Dof(ExoSel);    
        group_sign =Misc.Exo_group(ExoSel);

        if strcmp(Exo_Dof_sel,'ankle_angle_r')
            [~,ind_max]=max(qSel(:    ,ExoSel));
            [~,ind]=min(qSel(1:ind_max,ExoSel));
            t_min_ank =time_mesh(ind);
            t_max_ank =time_mesh(ind_max);

            % kvalue
            Exo_kvalue_lim(ExoSel,:)=[0 400];
            Exo_kvalue_IG(ExoSel)   =100;
            % engage
            timeExo_i_lim(ExoSel,:) =[t_min_ank t_max_ank];
            timeExo_i_IG(ExoSel)    =t_min_ank;
            % disengage
            timeExo_f_lim(ExoSel,:) =[t_max_ank t_toe_off];
            timeExo_f_IG(ExoSel)    =t_toe_off;
        end

        % apply limits
        opti.subject_to(Exo_kvalue_lim(ExoSel,1) < Exo_kvalue(trial,ExoSel) < Exo_kvalue_lim(ExoSel,end));

        opti.subject_to(timeExo_i_lim(ExoSel,1) < timeExo_i(trial,ExoSel) < timeExo_i_lim(ExoSel,end));
        opti.set_initial(timeExo_i(trial,ExoSel), timeExo_i_IG(ExoSel));

        opti.subject_to(timeExo_f_lim(ExoSel,1) < timeExo_f(trial,ExoSel) < timeExo_f_lim(ExoSel,end));
        opti.set_initial(timeExo_f(trial,ExoSel), timeExo_f_IG(ExoSel));

        opti.subject_to(timeExo_f(trial,ExoSel) - timeExo_i(trial,ExoSel) > 0);

        % bspline to relate angle and time
        qSel_val  = qSel(:,ExoSel);
        pp_casadi = casadi.interpolant('pp', 'bspline', {time_mesh}, qSel_val);
        qOffExo_i = pp_casadi(timeExo_i(trial,ExoSel));
        qOffExo_f = pp_casadi(timeExo_f(trial,ExoSel));

        % engage and disengage at the same angle
        opti.subject_to(qOffExo_i - qOffExo_f == 0);

        % exo dynamics
        BoolTime_high=tanh(1000*(time_mesh-timeExo_i(trial,ExoSel)))*0.5+0.5;
        BoolTime_low =tanh(1000*-(time_mesh-timeExo_f(trial,ExoSel)))*0.5+0.5;
        BoolTimeActive=BoolTime_high.*BoolTime_low;
        BoolqL = 1; 
        %                 BoolqL =(tanh(1000*(-group_sign.*(qSel_val-qOffExo_i)))*0.5+0.5); % this is need for passive-only exoskeleton
        BoolActive=BoolqL.*BoolTimeActive';

        Texo_SO(trial,ExoSel).T          = -((Exo_kvalue(trial,ExoSel).*((qSel_val-qOffExo_i)*pi/180)).*BoolActive')';
        Texo_SO(trial,ExoSel).Ind        = iSel(ExoSel); % index of applied torque
    end
end
end

for i=1:nDOF
    dM = squeeze(DatStore.dM(:,i,:));    
    Tm = sum(dM.*Fm,2); % torque generated by muscles
    Tr = ar(:,i).*Topt; % torque of ideal actuators
    T_exp=ID_data(:,i);
    
    % subtract exoskeleton moment from ID torque
    % (TID = Tmuscles + Texo)
    if Misc.Exo_Enable && Exo_Mode
        for ExoSel= 1:length(Misc.Exo_Dof)
            if i == Texo_SO(trial,ExoSel).Ind
                T_exp = T_exp - Texo_SO(trial,ExoSel).T';
            end
        end
    end
            
    opti.subject_to(T_exp == (Tm + Tr));
end

% Settings
optionssol.ipopt.nlp_scaling_method = 'gradient-based';
optionssol.ipopt.linear_solver = 'mumps';
optionssol.ipopt.tol = 1e-6;
optionssol.ipopt.max_iter = 1000;

% objective function
J = sumsqr(a) + 1000.*sumsqr(ar);
opti.minimize(J);

% Solver
opti.solver('ipopt',optionssol);
sol = opti.solve();


%% extract results

DatStore(trial).SoAct = sol.value(a);
DatStore(trial).SoRAct = sol.value(ar).*(Topt*ones(N,1));
DatStore(trial).SoForce = FMo.*(DatStore(trial).SoAct.*FMltilde.*FMvtilde + Fpe); 
DatStore(trial).cos_alpha = cos_alpha;





